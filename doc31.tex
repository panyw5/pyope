
\documentstyle[11pt]{article}
\def\be{\begin{equation}}
\def\bestar{\[\extraspace}
\def\ee{\end{equation}}
\def\eestar{\]}
\def\bv{\begin{verbatim}}
\def\bea{\begin{eqnarray}}
\def\beastar{\begin{eqnarray*}}
\def\eea{\end{eqnarray}}
\def\eeastar{\end{eqnarray*}}
\def\nonu{\nonumber \\[2mm]}
\def\leqn#1{\lefteqn{#1}\nonu}
\def\re#1{(\ref{#1})}
\def\vgl#1{eq.\ (\ref{#1})}

\def\dz{\partial}
\def\ie{{\sl i.e.\ }}
\def\eg{{\sl e.g.\ }}
\def\col{{\nolinebreak :}}
\def\KA{Ka\v{c}--Moody al\-ge\-bra}
\newcommand{\bin}[2]{\left(\!\!\!\begin{array}{c}#1\\#2\end{array}\!\!\!\right)}
\def\emt{en\-er\-gy--mo\-men\-tum tensor}

\newcounter{mathline}
\newcounter{mathref}
\newcounter{mathreftwo}
\def\un{\symbol{95}}
\def\ha{\symbol{94}}
\def\lb{\char'173}
\def\rb{\char'175}
\def\pc{\char'45}
\newlength{\tab}
\setlength{\tab}{5em}
\newcommand{\inm}[1]{\hspace*{9pt}\addtocounter{mathline}{1}
    \makebox[\tab][l]{\sl In[\themathline] :=}{\tt #1}}
\newcommand{\outm}[1]{\hspace*{9pt}
    \makebox[\tab][l]{\sl Out[\themathline] =}{\tt #1}}
\newcommand{\contm}[1]{\hspace*{9pt}
    \makebox[\tab][l]{}{\tt #1}}
\newcommand{\contmind}[1]{\hspace*{9pt}
    \makebox[\tab][l]{}{\hspace*{.8cm} \tt #1}}
\newcommand{\Mathematica} {{\sl Mathematica}}
\newcommand{\OPEdefs} {{\sl OPEdefs}}
\newcommand{\citeRef}[1]{\cite{#1}} % uncomment for preprint
\setcounter{mathline}{0}

\begin{document}
\begin{titlepage}
\title{A {\sl Mathematica\raise.6ex\hbox{\normalsize TM}} Package for
Computing Operator Product Expansions\\(OPEdefs 3.1)}
\author{K.\ Thielemans\thanks{Email address : k.thielemans@ic.ac.uk}
\\*[2mm]
% for preprint, comment \baselineskip and \scriptsize
%\scriptsize\sl
Theoretical Physics Group\\
%\scriptsize\sl
Imperial College\\
%\scriptsize\sl
London SW7 2BZ (UK)
}
\date{April 1995}
\vspace*{2cm}
\maketitle\thispagestyle{empty}
\begin{abstract}
A general purpose $\Mathematica^{TM}$ package for computing Operator
Product Expansions of composite operators in meromorphic conformal field
theory is described. Given the OPEs for a set of ``basic" fields,
OPEs of arbitrarily complicated composites can be computed
automatically.  Normal ordered products are always reduced to a standard
form. As an explicit example, the conformal anomaly for
superstrings is computed.

The most important extensions with respect to the first version of the
package are the ability the check the Jacobi identities, and to compute
Poisson brackets (``classical OPEs'').
\end{abstract}
\end{titlepage}

\section{Introduction}
%\baselineskip=14 pt % comment for preprint
Operator Product Expansions (OPEs) are extensively used in conformal field
theories, for example in string theory and statistical physics.  They are
used to evaluate expectation values of several fields with arguments in
neighbouring points.  One then writes
\begin{equation} A(z) B(w) =
\frac{C(w)}{(z-w)^2} + \frac{D(w)} {z-w} + \dots
\end{equation}
where the dots represent the regular terms in the Laurent expansion.
The above expression is valid when evaluating expectation
values for $z \rightarrow w$.

In handling OPEs, the problem of normal ordering requires special
attention. In the so called {\sl
point splitting regularization} scheme, the normal ordered
product of two operators is defined as the zero'th order term in their OPE.
The OPE of an operator with a composite follows from a variation
on Wick's theorem \cite{formula}.
However, calculations quickly become
long and error prone when composites of composites are involved.

The definition of normal ordering is noncommutative and nonassociative.  As
a consequence, it is recommended to use a standard order for the operators
and introduce a standard way of normal ordering composites of several
operators.  To this end, there exists a set of prescriptions and again these
formulas are conceptually quite simple, but have to be applied recursively
in complicated cases.

\OPEdefs\ is written in $Mathematica^{TM}$ \footnote{ \Mathematica\ is a
trademark of Wolfram Research Inc.  For details, see \citeRef{Wolfram}.}, an
interactive environment for performing symbolic computations.  The
advantages of writing the package in \Mathematica\ are numerous.  Its
programming language has very powerful pattern matching capabilities.  The
result of a computation can be transformed with the help of built-in
functions (expanding, factoring, collecting terms in specified variables
$\dots$) and one may even obtain output in \TeX-form.  \Mathematica\ is
running on a lot of machines, from PC's to supercomputers and all versions
are completely compatible.  And last but not least, it is considerably less
time-consuming to program this problem in \Mathematica\ than, for instance,
in $C$.

In using the package, all ``basic" operators
of the theory have to be declared to be bosonic or fermionic
(parafermions are not supported), and the OPEs of the basic
operators must be given.  Fields with any (also negative)
conformal dimension may be used, the only restriction
is that fractional powers in the Laurent expansion
are not supported.  With this input, the package is able to compute
OPEs of arbitrarily complicated composites, given
enough memory and time.  Also, normal ordered products are automatically
reduced to standard form (putting operators in the order they are declared
and normal ordering them from right to left).

Version 2.0 of \OPEdefs\ is already presented in \citeRef{OPEdefs2.0}.
Version 3.0 is described in
\citeRef{OPEdefs3.0}. In this paper, version 3.1 is briefly described.
A more complete overview of the OPE formalism and of the internals of
\OPEdefs\ is given in \citeRef{KTthesis} to which I refer for further details.

The paper is organised as follows. In section 2, the necessary rules for
computing OPEs are given and the algorithm is discussed briefly.
The next section explains how to use the package. Finally, some
runtimes are given.

\subsubsection*{Notation}
Input for and output from \Mathematica\ is written in {\tt typeset} font.
Input lines are preceded by ``{\sl In[n] :=}", and corresponding output
statements by ``{\sl Out[n] =}", as in \Mathematica.

We use the following notation for OPEs
\begin{equation}
A(z) B(w) = \sum_{n <= h(A,B)}{\frac{{[}AB{]}_n(w)}{(z-w)^n}} \ \ ,
\label{eq:OPEdef}
\end{equation}
where $h(A,B)$ is some finite number, and is usually given by the sum
of the conformal dimensions of $A$ and $B$. ${[}AB{]}_0$ will be called the
normal ordered product of $A$ and $B$.

For Poisson (or in fact Dirac) brackets we use
\be
\{A(x),B(x_0)\}_{\rm PB} = \sum_{n>0}{(-1)^{n-1} \over (n-1)!}\{AB\}_n(x_0)
    \dz^{n-1}\delta^{(2)}(x-x_0)\,,
\label{eq:PBdef}
\ee
where $\delta^{(2)}(x-x_0)$ is the Dirac delta-function on the plane.
The derivative is with respect to the $x$--coor\-di\-nate.
We choose the normalisation factors such that\col
\be
\{AB\}_n(y) =\int dx^2\ (x-y)^{n-1} \{A(x),B(y)\}_{\rm PB}\,.
\ee

\section{Formulas}
In \citeRef{OPEdefs2.0}, all formulas (extracted from \citeRef{formula})
needed to compute OPEs are given. The more complicated rules can be
derived in the following way, see \citeRef{KTthesis} for more details.

Using the definition \re{eq:OPEdef} for the OPEs, and Cauchy's residue
formula for contour integrals, we can isolate
the contribution of a certain part of the OPE by taking appropriate
contour integrals\col
\bea \leqn{[A[BC]_p]_q (u) \, =
 \oint_{C_u} {dz\over 2\pi i}\, (z-u)^{q-1}\hspace*{3em}}
&&        \oint_{C_u} {dw\over 2\pi i}\, (w-u)^{p-1}\,A(z)B(w)C(u)\,,
\label{eq:OPEcontoursR}
\eea
where $C_u$ denotes a contour which encircles $u$ once anti-clockwise.
We can now use a contour deformation argument relating the contour integral
in \vgl{eq:OPEcontoursR} to a contour integral where the integration over
$w$ is performed last. This integral has two
terms\col\ one where the $z$ contour is around $u$, and one where it is
around $w$. We find\col
\bea
[A[BC]_p]_q
=(-1)^{|A|\,|B|} [B[AC]_q]_p + \sum_{l>0}\bin{q-1}{l-1}[[AB]_{l}C]_{p+q-l}
    \label{eq:OPEJacRAB}\,.
\eea
This equation has to hold (inside correlators) for consistency of the 
OPE-formalism. It is valid for {\sl any} integers $p,q$, \ie also
negative numbers. However, in practice we use the Jacobi identities
\vgl{eq:OPEJacRAB} for positive $p,q$ as equations for the singular
part of the OPEs, while for $p$ or $q$ zero, they define how one should
calculate with composites.

\OPEdefs\ 3.1 can calculate OPEs and Poisson brackets. We concentrate on
OPEs here and briefly comment which changes are needed for the other case.
However, note that the Jacobi identities \vgl{eq:OPEJacRAB} for positive
$p,q$ remain exactly the same.

\subsubsection{Computing OPEs}
The package should compute OPEs of arbitrarily complicated composites
when a set of generators and their OPEs is given.  For easy
reference, we list the rules we need, aside from linearity.
First, there are the rules involving derivatives\col
\bea
[\dz A\,B]_{q}& =& -(q-1) [AB]_{q-1} \label{eq:RulePolederL}\\[2mm]
[A\,\dz B]_{q}& =& (q-1) [AB]_{q-1} + \dz [AB]_{q}\,.
    \label{eq:RulePolederR}
\eea
Next, we need the OPE of $B$ with $A$, given the OPE of
$A$ with $B$\col \be
[BA]_q = (-1)^{|A||B|}
\sum_{l\geq q}{\frac{(-1)^l}{(l-q)! } \partial^{(l-q)}[AB]_l}
\label{eq:RuleOPEcomm}\,.
\ee
OPEs with composites can be calculated using \vgl{eq:OPEJacRAB}\col
\bea
[A\ [BC]_0]_q &=& (-1)^{|A||B|} [B\ [AC]_q]_0 + [[AB]_q\ C]_0\nonu
&& + \sum_{l=1}^{q-1} \bin{q-1}{l} [[AB]_{q-l}C]_l
\label{eq:RuleOPEcompRAB}
\eea
where $q \geq 1$. Furthermore, we will use\col
\be
[AA]_0 = -\sum_{l>0}{(-1)^{l}\over 2l!} \partial^l [AA]_{l}
\ ,\ \ \ \mbox{for $A$ fermionic .}
\label{eq:Rulecompfermion}
\ee

These rules are the only ones needed to compute every OPE in the OPA.
Indeed, when computing the OPE of $A$ with $B$, we apply the following
procedure\col
\begin{itemize}
\item if $A$ and $B$ are generators whose OPE we know, return it as
   the result.
\item apply linearity if necessary.
\item if $A$ is an operator with derivatives, use \vgl{eq:RulePolederL}.
\item if $B$ is an operator with derivatives, use \vgl{eq:RulePolederR}.
\item if $A$ or $B$ contains a composite, apply \vgl{eq:Rulecompfermion}
if necessary.
\item if $B$ is a composite, use \vgl{eq:RuleOPEcompRAB}.
\item if $A$ is a composite, use \vgl{eq:RuleOPEcomm}.
\item if the OPE $B(z)\ A(w)$ is known, compute the OPE $A(z)\ B(w)$ using
  \vgl{eq:RuleOPEcomm}.
\end{itemize}
This list should be used recursively until none of the rules applies,
which means that the OPE has been calculated. The order in which we check
the rules is in this case not important, but we will check them in a
``top-down'' order. Note that to compute an OPE of a composite with a
generator, first \vgl{eq:RuleOPEcomm} is used, and
\vgl{eq:RuleOPEcompRAB} in the next step.

The algorithm used to compute Poisson brackets is essentially the same.
Some small changes in the rule \vgl{eq:RuleOPEcompRAB} are needed, namely all
double contractions have to be dropped. Also, \vgl{eq:Rulecompfermion}
is changed to $[AA]_0=0$ when $A$ is fermionic.

\subsubsection{Simplifying composites}
We now discuss how we can reduce normal ordered products
to a standard form. We define an order on the generators and their
derivatives, \eg lexicographic ordering. Given a composite, we apply the
rules given below until all composites are normal
ordered from right to left and the operators are ordered, \ie
$[A[B[C\ldots]_0]_0]_0$, and $A\leq B\leq C$. The relevant formulas
are\col
\bea
&&\dz [AB]_0= [A\ \dz B]_0 + [\dz A\ B]_0 \label{eq:RuleNOder}\\[2mm]
&&[AB]_{-q} = {1\over q!} [(\dz^q \!\!A)\ B]_0\,,\qquad\qquad q\geq 1
\label{eq:RulePoleregdef} \\[2mm]
&&[BA]_0 = (-1)^{|A||B|} [AB]_0 + (-1)^{|A||B|}
\sum_{l\geq 1}{\frac{(-1)^l}{l! } \partial^{l}[AB]_l}
\label{eq:RuleNOcomm}\\[2mm]
&&[A\ [BC]_0]_0 = (-1)^{|A||B|} [B\ [AC]_0]_0 +\\[2mm]
&&\qquad\qquad [([AB]_0 -
(-1)^{|A||B|}[BA]_0)\ C]_0 \label{eq:RuleNOcompR}
\eea

For the case of Poisson brackets, the rules \re{eq:RuleNOcomm} and
\re{eq:RuleNOcompR} drastically simplify, only the first terms remain.

\subsubsection{Improvements}
The rules given in this section up to now are sufficient to
compute any OPE, and to reorder any composite into a standard form.
However, some shortcuts exist
\footnote{
Eqs. (\ref{eq:RuleOPEcompRBA})- (\ref{eq:RuleNOcompL}) follow from
the familiar
argument of splitting the paths of a contour-integral, and using
${[}A\ B{]}_{-n} = {1 \over {n!}} {[}A^{(n)}\ B{]}_0$ for positive $n$,
where $A^{(n)}$ denotes the $n$-th derivative of $A$.},
and where introduced in \OPEdefs\ 3.x.

 $[A\ [BC]_0]_q$ can be computed using
\vgl{eq:RuleOPEcompRAB}, but an alternative is\col
\bea
[A\ [BC]_0]_q &=&
 (-1)^{|A||B|}\Big( [B\ [AC]_q]_0 + \sum_{l\geq 0}{(-1)^{l+q}\over l!}
               [\dz^l[BA]_{l+q}\ C]_0\nonumber\\
&& \qquad\qquad +\sum_{l=1}^{q-1}(-1)^l [[BA]_l\ C]_{q-l}\Big)\,.
    \label{eq:RuleOPEcompRBA}
\eea
This rule is more convenient when we know the OPE $B(z)A(w)$ while
$A(z)B(w)$ has to be computed using \vgl{eq:RuleOPEcomm}.

Similarly, to compute an OPE where the first operator is a composite,
the algorithm as presented above uses eqs.\ \re{eq:RuleOPEcomm}
and \re{eq:RuleOPEcompRAB}. However, the next rule
implements this in one step\col
 \bea [[AB]_0\ C]_q &=&
    \sum_{l\geq 0}{1 \over l!}  [\dz^l A\ [BC]_{l+q}]_0
   + (-1)^{|A||B|}\sum_{l\geq 0}{1 \over l!} [\dz^l B\ [AC]_{l+q}]_0
\nonumber\\
   & & + (-1)^{|A||B|} \sum_{l=1}^{q-1} [B\ [AC]_{q-l}]_,,
\label{eq:RuleOPEcompL}
\eea
where $q \geq 1$ and\col
\bea
[[AB]_0 C]_0 &=&
    [A[BC]_0]_0 +\nonumber\\
&&    \sum_{l>0} {1 \over l!} [\dz^l A\ [BC]_{l}]_0
    + (-1)^{|A||B|} \sum_{l>0}{1\over l!} [\dz^l B\ [AC]_{l}]_0 \,.
 \label{eq:RuleNOcompL}
\eea

In \OPEdefs\ 3.1 these two last rules are applied when $C$ is not a composite
itself.

\section{User's Guide\label{sct:OPEdefsGuide}}
\setcounter{mathline}{0}
This section is intended as a user's guide to the package \OPEdefs\
3.1. Explicit examples are given for most operations. Note that
\OPEdefs\ 3.1 requires \Mathematica\ 1.2 or later.

We introduce some special notations. Input for and output from
\Mathematica\ is written in {\tt typeset} font. Input lines are preceded
by ``{\sl In[n] :=}'', and corresponding output statements by ``{\sl
Out[n] =}'', as in \Mathematica.

As \OPEdefs\ is implemented as a \Mathematica\ package, it has to be
loaded {\em before} any of its global symbols is used. Loading the
package a second time will clear all previous definitions of operators
and OPEs, as well as all stored intermediate results. Assuming that the
package is located in the {\sl Mathematica}-path, \eg\ in your current
directory, issue\col
\\[2mm] \inm{<<OPEdefs.m}\\[2mm]
After loading \OPEdefs\ into \Mathematica, help for all the global
symbols is provided using the standard help-mechanism, \eg {\tt ?OPE}.

Now, you need to declare the operators that will be used. If you
want to define bosonic operators {\tt T} and {\tt J[i]} (any index
could be used), and fermionic operators {\tt psi[i]}, the
corresponding statements are\col
\\[2mm] \inm{Bosonic[T, J[i\un]]}
\\ \inm{Fermionic[psi[i\un]]}\\[2mm]
The order of the declarations fixes also the
ordering of operators used by the program\col
\be
\mbox{{\tt T < J[1]' < J[1] < J[2] < J[i] < psi[1] < ...
}} \label{eq:OPEdefsOrder}
\ee
By default, derivatives of an operator are considered ``smaller'' than
the operator itself. This can be reversed using the global options {\tt
NOOrdering} (see  below).

Finally, the non-regular OPEs between the basic operators
have to be given. An OPE can be specified in two different ways.\\
The first way is by listing the operators that occur at the poles, the
first operator in the list is the one at the highest non-zero pole,
the last operator has to be the one at the first order pole, \eg
\col
\\[2mm] \inm{OPE[T, T] = MakeOPE[\lb c/2 One, 0, 2T, T' \rb];}\\[2mm]
Note the operator {\tt One} which specifies the unit-operator.\\
The second way is by giving the OPE as a Laurent series expansion,
adding the symbol {\tt Ord} which specifies the (implicit) arguments of the
operators for which the OPE is defined\footnote{The first time
you use this syntax, you may notice an unexpected delay. This is
because \Mathematica\ is loading the {\tt Series} package.}.
The arguments for the operators can be any \Mathematica\ expression.

\noindent{\bf Warning}\col\ it is important that the operators occuring as
arguments of {\tt OPE} in a definition should be given in standard
order (\ref{eq:OPEdefsOrder}), otherwise wrong results will be
generated.

The following statements define a $\widehat{SU(2)}_k$-\KA\col
\\[2mm] \inm{OPE[J[i\un],J[i\un]] :=}
\\ \contm{ MakeOPE[-k/2 (z-w)\ha-2+ Ord[z,w,0]]}
\\ \inm{OPE[J[1],J[2]] = }
\\ \contm{ MakeOPE[J[3][w](z-w)\ha-1 +Ord[z,w,0]];}
\\ \inm{OPE[J[2],J[3]] =}
\\ \contm{  MakeOPE[J[1][w](z-w)\ha-1 + Ord[z,w,0]];}
\\ \inm{OPE[J[1],J[3]] =}
\\ \contm{  MakeOPE[-J[2][w](z-w)\ha-1 + Ord[z,w,0]];}\\[2mm]
In fact, with the above definitions, one has to use always
the explicit indices $1,2,3$ for the currents $J$. If we would compute
an OPE with current {\tt J[i]} where the index $i$ is not $1,2$ or $3$,
wrong results will be given. One can circumvent this peculiarity by
reformulating the definitions.

A normal ordered product $[ A B ]_0$ is entered in the form {\tt
NO[A,B]}. Multiple composites can be entered using only one {\tt
NO} head, \eg {\tt NO[A,B,C]}. This input is effectively translated
into {\tt NO[A, NO[B, C]]}. All output is normal ordered with the same
convention, \ie from right to left (input can be in any order). Also,
the operators in composites will always be
ordered according to the standard order (\ref{eq:OPEdefsOrder}).\\
As an example, we can define the Sugawara energy-momentum tensor for
$\widehat{SU(2)}_k$. The \Mathematica\ output of an OPE is a list of the
operators at the poles.
\\[2mm] \inm{Ts = -1/(k+2)(NO[J[1],J[1]]+}
\\ \contmind{NO[J[2],J[2]]+NO[J[3],J[3]]);}
\\ \inm{OPESimplify[OPE[Ts, J[1]]]}
\\ \outm{<< 2|| J[1] ||1|| J[1]' >>}
\setcounter{mathref}{\value{mathline}}
\vspace*{2mm}

\noindent{\bf Warning}\col\ when computing OPEs with composites, or when
reordering composites, \OPEdefs\ remembers by default some
intermediate results. Thus, it is dangerous to change the definition of
the basic OPEs after some calculations have been performed. For example,
consider a constant $a$ in an OPE. If calculations are performed after
assigning a value to $a$, the intermediate results are stored with this
value. Changing $a$ afterwards will give wrong results.

The other globally defined functions available from the package
are\col
\begin{itemize}
\item \verb&OPEOperator[operator_, parity_]& provides a more general way to
declare an operator than {\tt Bosonic} and {\tt Fermionic}. The second
argument is the parity of the operator such that $(-1)^{\tt parity}$ is
$+1$ for a boson, and $-1$ for a fermion. It can be a symbolic constant.
This is mainly useful for declaring a $bc$-system of unspecified parity, or a
\KA\ based on a super-Lie algebra. In such cases, the operator can contain a
named pattern\col
\\ \inm{OPEOperator[J[i\un],parity[i]]}\\
If one wants to declare more operators, one can group each operator and its
parity in a list\col
\\ \inm{OPEOperator[\{b[i\un],parity[i]\},\{c[i\un],parity[i]\}]}\\
See also {\tt SetOPEOptions[ParityMethod, \un]}.
\item \verb&OPEPole[n_][ope_]& gets a single pole term of an OPE\col
\\ \inm{OPEPole[2][Out[\themathref]]}
\\ \outm{J[1]}\\
\verb&OPEPole[n_][A_,B_]& can also be used to compute only one pole term of
an OPE\col
\\ \inm{Factor[OPEPole[4][Ts, Ts]]}
\\ \outm{(3 k One)/(2 (2 + k))}\\
{\tt OPEPole} can also give terms in the regular part of the OPE\col
\\ \inm{OPEPole[-1][T, T]}
\\ \outm{NO[T', T]}
\item \verb&MaxPole[ope_]& gives the order of the highest pole in the OPE.
\item \verb&OPEParity[A]& returns an even (odd) integer of $A$ is
bosonic (fermionic).
\item \verb&OPESimplify[ope_, function_]& ``collects'' all terms in
{\tt ope} with the same operator and applies {\tt function} on the
coefficients. When no second argument is given, the coefficients
are {\tt Expand}ed.
\\[2mm] \inm{OPESimplify[OPE[J[1], NO[J[2], J[1]]]]}
\\ \outm{<< 2|| (1 - k/2) J[2] ||1||}
\\ \contm{\ \ \ NO[J[1], J[3]] + J[2]' >>}\\[2mm]
\verb&OPESimplify[pole_, function_]& does the same simplifications
on sums of operators.
\item \verb&OPEMap[function_, ope_]& maps {\tt function} to all poles of
{\tt ope}.
\item \verb&GetCoefficients[expr_]& returns a list of all
coefficients of operators in {\tt expr} which can be (a list of) OPEs
or poles.
\item \verb&OPEJacobi[op1_,op2_,op3_]& computes the
Jaco\-bi-iden\-ti\-ties \re{eq:OPEJacRAB} for the singular part of
the OPEs of the three arguments. Due to the nature of
\vgl{eq:OPEJacRAB}, the computing time will be smallest (in most
cases) when {\tt op1} $\leq$ {\tt op2} $\leq$ {\tt op3} in the order
\re{eq:OPEdefsOrder}. Note that it is sufficient to check the
Jaco\-bi-iden\-ti\-ties with the generators of the OPA.\\
The result of {\tt OPEJacobi} is a double list of operators. It is
generated by\\
\hspace*{4em}{\tt
Table[OPEPole[n][A,OPEPole[m][B,C]] +}\\ \hspace*{8em}{\tt {\sl
corrections},\  \{m, maxm\},\{n,maxn\}]}\\
All elements of the list
should be zero up to null operators for the OPA to be associative.
\item \verb&Delta[i_,j_]& is the Kronecker delta symbol
$\delta_{ij}$.
\item \verb&ClearOPESavedValues[]& clears all stored
intermediate results, but not the definition of the operators and
their OPEs. To clear everything, reload the package.
\item \verb&OPEToSeries[ope_]& converts
an OPE to a Laurent series expansion in {\tt z} and {\tt w}. The
arguments can be set to {\tt x} and {\tt y} with\col
\\ \inm{SetOPEOptions[SeriesArguments, \{x, y\}]}
\item \verb&TeXForm[ope_]& gives \TeX output for
an OPE. The same arguments are used as in \verb&OPEToSeries&.
\item \verb&OPESave[filename_]& (with {\tt filename} a string between
double quotes) saves the intermediate results that \OPEdefs\ remembers
to file (see the option {\tt OPESaving} below).
\item {\tt SetOPEOptions} is a function to set the global options of
the package. The current options are\col
\begin{itemize}
\item \verb&SetOPEOptions[SeriesArguments, {arg1_,
arg2_}]& : sets arguments to be used by {\tt TeXForm} and {\tt
OPEToSeries}. One can use any Mathematica expression for {\tt arg1}
and {\tt arg2}.
\item \verb&SetOPEOptions[NOOrdering, n_]& :
if {\tt n} is negative, order higher derivatives to the left
(default), if {\tt n} is positive, order them to the right.
\item \verb&SetOPEOptions[ParityMethod, 0|1]& : makes it possible to use
operators of an unspecified parity. When the second argument is $0$
(default), all operators have to be declared to be bosonic or
fermionic. When the argument is $1$, {\tt OPEOperator} can be used with
a symbolic parity.
Note that in this case, powers of $-1$ are used to compute signs, which is
slightly slower than the boolean function which is used by the first
method.\\
This option is not normally needed as the use of {\tt
OPEOperator} with a non-integer second argument sets this option
automatically.
\item \verb&SetOPEOptions[OPESaving, boolean_]& :
if {\tt boolean} evaluates to {\tt True} (default), \OPEdefs\
stores the intermediate results when computing OPEs of composites and
when reordering composites. This option is useful if \Mathematica\ runs
short of memory in a large calculation, or when computing with dummy
indices\footnote{No mechanism to use dummy indices is built-in in
\OPEdefs. I wrote a separate package {\sl Dummies} to handle
this.}.
\item \verb&SetOPEOptions[OPEMethod, method_]& :
with the parameter {\tt method} equal to {\tt Quan\-tum\-OPEs} enables
normal OPE computations (default setting), while {\tt Classi\-cal\-OPEs}
enables Poisson bracket computations. Using this option implicitly calls
\verb&ClearOPESavedValues[]&.
\end{itemize}
\end{itemize}

\section{Example : The conformal anomaly in superstring
theory\label{eq:OPEexample}}
\setcounter{mathline}{0}
We consider only one free boson field $X$ and one free fermion
field $\psi$ because additional free fields will have exactly the same OPEs
and commute with each other. We denote $\dz X$ with {\tt J} and $\psi$
with {\tt psi} (we normalise them such that they have a $+1$ in their
OPEs. The ghosts are a
fermionic $b$, $c$ system (operators {\tt b,c}) and a bosonic $\beta$,
$\gamma$ system (operators {\tt B,G}). $b$ has conformal
dimension $2$ and $\beta$ has $3/2$. It is now a
trivial task to compute the conformal anomaly\col
\\[2mm] \inm{<<OPEdefs.m}
\\ \inm{Bosonic[J,B,G]; Fermionic[b,c,psi];}
\\ \contm{OPE[J,J] = MakeOPE[\{One, 0\}];}
\\ \contm{OPE[psi,psi] = MakeOPE[\{One\}];}
\\ \contm{OPE[b,c] = MakeOPE[\{One\}];}
\\ \contm{OPE[B,G] = MakeOPE[\{One\}];}
\\ \contm{Tb = 1/2 NO[J,J]; Tf = -1/2 NO[psi,psi'];}
\\ \contm{Tbc = -2 NO[b,c'] - NO[b',c];}
\\ \contm{TBG = 3/2 NO[B,G'] + 1/2 NO[B',G];}
\\[2mm] \inm{OPESimplify[OPE[Tb,Tb]]}
\\ \outm{<< 4|| One/2 ||3|| 0 ||2|| NO[J, J] ||1||}
\\ \contmind{ NO[J', J] >>}
\\ \inm{OPESimplify[OPE[Tf,Tf]]}
\\ \outm{<< 4|| One/4 ||3|| 0 ||2|| NO[psi', psi] ||1||}
\\ \contmind{ NO[psi'', psi]/2>>}
\\ \inm{OPESimplify[OPE[Tbc,Tbc]]}
\\ \outm{<< 4|| -13 One ||3|| 0 ||2||}
\\ \contmind{ -4 NO[b, c'] - 2 NO[b', c]||1||}
\\ \contmind{ -2 NO[b, c''] - 3 NO[b', c'] - NO[b'', c] >>}
\\ \inm{OPESimplify[OPE[TBG,TBG] - MakeOPE[\{2 TBG,TBG'\}]}
\\ \outm{<< 4|| 11 One/2 ||3|| 0 ||2|| 0 ||1|| 0 >>} \\[2mm]
We see that each bosonic (fermionic) field will contribute a
central charge $1$ ($1/2$) to the total central charge of the theory.
The $b$, $c$ system contributes $-26$, and the $\beta$, $\gamma$
system $11$. This gives the well known relation for the critical
dimensions of the bosonic string $D_b - 26 = 0$ and the superstring $3/2
D_s -26 + 11 = 0$.  Moreover, we can easily verify that the {\emt}s obey
the Virasoro algebra .

The reader without experience in CFT is invited at this point to take
out some time and compute the OPE for $T_{BG}$, for instance, by hand.
Although this computation is rather trivial with \OPEdefs, the same
calculation was attempted in \cite{SUPERCALC} using the mode--algebra.
There it proved not to be possible to compute the Virasoro algebra
automatically due to difficulties with the infinite sums in the normal
ordered products.


\section{Performance}
In \citeRef{OPEdefs2.0}, a free field realization for $\widehat{B_2}$ level $k$
using (bosonic) $\beta$, $\gamma$ systems was constructed.  In Table
\ref{table:CPU}, we tabulate CPU times for computing an OPE of two of the
currents, and the Sugawara tensor for this realization.  The first time
given in the table is the time for evaluating the statement after loading
the package and defining the realization.  The time between brackets is
measured when the statement is repeated.  Note that version 2.0 of
\Mathematica is roughly 1.4 times slower than version 1.2\nolinebreak !

\begin{table}[hbt]
\caption{CPU time for the computation of the OPE of the currents
corresponding to the positive simple root of $\widehat{B_2}$ (statement
9) and the computation of the Sugawara tensor (statement 11) (see Ref.
\protect\cite{OPEdefs2.0}) for \Mathematica\ running on a PC 386 (25
Mhz).
\label{table:CPU} }
\vspace{.1 cm}
\begin{center}
\begin{tabular}{|l||c|c|c|}
\hline
                      &             &              & \\*[-.2cm]
{\Mathematica}-version &    1.2     &  1.2         & 2.0 \\
{\OPEdefs}-version     &    2.0     &  3.1         & 3.1 \\
                      &             &              & \\*[-.2cm]
\hline
                      &             &              & \\*[-.2cm]
{\tt In[9]}
                      &23.5 (4.5) s & 14.9 (2.8) s & 19.3 (3.8) s \\
{\tt In[11]}
                      &43.2 (11.6) s& 31.3 (9.4) s & 40.7 (12.1) s\\*[.2cm]
\hline
\end{tabular}
\end{center}
\end{table}

\section{How to get it, and the future}
If you are interested in \OPEdefs, you can get it
by Email from the author. Please put a reference to \citeRef{OPEdefs2.0} in your
paper when you use it. Questions, remarks
and improvements are welcome. Already in testing-phase is {\sl OPEconf},
a package which enables you to work with (quasi-)primaries and
conformal blocks.

\section{Acknowledgements}
Many improvements implemented in \OPEdefs\ 3.0 are suggested by K. Hornfeck,
who also helped me testing this version.

\begin{thebibliography}{9}
\bibitem{formula} F. Bais, P. Bouwknegt, M. Surridge, K. Schoutens, Nucl.
Phys. {\bf B304} (1988) 348.\\
A. Sevrin, W. Troost, A. Van Proeyen, P. Spindel, Nucl. Phys. {\bf B311}
465 (1988).
\bibitem{Wolfram} {\sl Mathematica, A system for Doing Mathematics
by Computer}, S. Wolfram, Addison-Wesley Publishing Company, Inc.
\bibitem{OPEdefs2.0} K. Thielemans, Int. J. Mod. Phys. C Vol. {\bf 2}, No. 3,
787 (1991).
\bibitem{OPEdefs3.0}
   K. Thielemans, {\sl New computing techniques in
   Physics Research II},  proceedings of the Second International
   Workshop on Software Engineering,  Artificial Intelligence and Expert
   Systems in High Energy and  Nuclear Physics, ed. D. Perret-Gallix,
   World Scientific (1992).
\bibitem{KTthesis}
   K. Thielemans, {\sl An Algorithmic Approach to Operator Product
   Expansions, $W$-algebras and $W$-strings}, PhD thesis KU Leuven, june 1994.
\bibitem{SUPERCALC}
    W.M. Seiler, {\sl SUPERCALC, a REDUCE Package for
   commutator calculations}, Karlsruhe preprint KA-THEP-20/90.
\end{thebibliography}

\end{document}
