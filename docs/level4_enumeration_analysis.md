# Level 4 Null States 枚举结果分析

**文档创建日期**: 2026-01-09
**状态**: 待解决 (改天再来处理)

## 1. 概述

本文档记录了 pyope 库在计算 Z₃ W-algebra Level 4 Null States 时，与 Mathematica 参考实现的枚举结果差异。

### 1.1 核心问题

pyope 当前的算符枚举器产生的算符数量与 Mathematica 不匹配：

- **pyope 枚举**: 55 个算符（m≥0 扇区：52 个）
- **Mathematica 参考**: 41 个算符（m≥0 扇区）
- **差异**: +11 个算符（27% 过度枚举）

### 1.2 计算结果对比

| 指标           | pyope (当前) | Mathematica (参考) | 差异 |
| -------------- | ------------ | ------------------ | ---- |
| 总抽象态数     | 4            | 41                 | -37  |
| 总秩           | 4            | 6                  | -2   |
| 总 Null states | 0            | 35                 | -35  |

**注意**: pyope 的结果是应用了线性独立性过滤后的结果，过滤过于激进。

---

## 2. 枚举器演进历史

### 2.1 版本 1: 简单枚举器

- **实现**: 只枚举单个生成元的导数
- **结果**: 4 个算符
- **问题**: 缺少生成元的正规序乘积

### 2.2 版本 2: 完整枚举器

- **实现**:
  - 单个生成元的导数
  - 两个生成元的正规序乘积 NO(g1, g2)
  - 正规序乘积的导数
- **结果**: 85 个算符（m≥0 扇区：82 个）
- **问题**: 严重过度枚举（2倍于 Mathematica）

### 2.3 版本 3: 优化枚举器（i ≤ j 约束）

- **实现**:
  - 添加 `i ≤ j` 约束避免重复组合
  - 右结合形式：NO(a1, NO(a2, a3))
- **结果**: 55 个算符（m≥0 扇区：52 个）
- **改进**: 减少了 37% 的过度枚举
- **问题**: 仍然比 Mathematica 多 11 个算符

### 2.4 版本 4: 线性独立性过滤

- **实现**:
  - 在版本 3 基础上添加 `_filter_linearly_independent` 方法
  - 逐个添加算符，检查矩阵秩是否增加
- **结果**: 4 个算符（m≥0 扇区）
- **问题**: **过滤过于激进**，丢失了大量物理上有意义的算符

---

## 3. 量子数扇区详细对比

### 3.1 完整对比表

| 量子数 (m, r) | pyope (无过滤) | pyope (有过滤) | Mathematica | 状态      |
| ------------- | -------------- | -------------- | ----------- | --------- |
| (3, 0)        | 3              | 0              | 2           | ✗ 不匹配 |
| (2, 1)        | 1              | 1              | 1           | ✓ 匹配   |
| (2, -1/2)     | 0              | 0              | 4           | ? 缺失    |
| (1, 1/2)      | 4              | 1              | 11          | ✗ 不匹配 |
| (1, -1)       | 0              | 0              | 2           | ? 缺失    |
| (0, 0)        | 44             | 2              | 21          | ✗ 不匹配 |

### 3.2 扇区分析

#### (0, 0) 扇区 - 严重过度枚举

- **pyope**: 44 个算符（无过滤）→ 2 个（有过滤）
- **Mathematica**: 21 个算符
- **问题**:
  - 无过滤时过度枚举 +23 个（110% 过度）
  - 有过滤时欠枚举 -19 个（90% 欠缺）

#### (1, 1/2) 扇区 - 欠枚举

- **pyope**: 4 个算符（无过滤）→ 1 个（有过滤）
- **Mathematica**: 11 个算符
- **问题**:
  - 无过滤时欠枚举 -7 个（64% 欠缺）
  - 有过滤时欠枚举 -10 个（91% 欠缺）

#### (3, 0) 扇区 - 轻微过度枚举

- **pyope**: 3 个算符（无过滤）→ 0 个（有过滤）
- **Mathematica**: 2 个算符
- **问题**:
  - 无过滤时过度枚举 +1 个（50% 过度）
  - 有过滤时完全缺失

#### (2, 1) 扇区 - 完美匹配 ✓

- **pyope**: 1 个算符（无过滤和有过滤）
- **Mathematica**: 1 个算符
- **状态**: **唯一完全匹配的扇区**

#### (2, -1/2) 和 (1, -1) 扇区 - 完全缺失

- **pyope**: 0 个算符
- **Mathematica**: 4 个和 2 个算符
- **问题**: 这些扇区的算符可能需要 3 个或更多生成元的乘积

---

## 4. 根本原因分析

### 4.1 枚举策略问题

#### 问题 1: 缺少多生成元乘积

当前枚举器只实现了：

- 单个生成元的导数
- **两个**生成元的正规序乘积

但 Mathematica 可能使用了：

- **三个或更多**生成元的正规序乘积
- 例如：NO(g1, NO(g2, NO(g3, g4)))

**证据**: (2, -1/2) 和 (1, -1) 扇区完全缺失，这些扇区的量子数组合可能需要更复杂的乘积。

#### 问题 2: 枚举规则不明确

Mathematica 的枚举规则可能包括：

- 特定的生成元组合优先级
- 基于物理意义的筛选规则
- 特定的导数阶数限制

**当前实现**: 使用 `max_derivative_order=10` 的暴力枚举，没有物理约束。

### 4.2 线性独立性过滤问题

#### 核心问题

`_filter_linearly_independent` 方法选择的是**数学上线性独立**的算符，而不是**物理上有意义的标准基底**。

#### 过滤逻辑

```python
def _filter_linearly_independent(self, operators, fock_basis):
    independent_ops = []
    current_rank = 0
    for op in operators:
        test_ops = independent_ops + [op]
        matrix_builder = CoefficientMatrixBuilder(fock_basis, test_ops)
        new_rank = matrix_builder.compute_rank(matrix_builder.build_matrix())
        if new_rank > current_rank:
            independent_ops.append(op)
            current_rank = new_rank
    return independent_ops
```

#### 问题分析

1. **顺序依赖**: 过滤结果依赖于算符的枚举顺序
2. **贪心选择**: 选择第一个增加秩的算符，而不是物理上最简单的算符
3. **缺少物理约束**: 没有考虑算符的物理意义和标准形式

#### 正确的方法

Mathematica 可能使用：

- 预定义的标准基底形式（例如：优先选择简单的 NO 组合）
- 基于物理意义的排序（例如：按生成元的物理角色排序）
- 特定的构造规则（例如：Virasoro 代数的标准基底）

---

## 5. 待解决问题清单

### 5.1 高优先级

1. **理解 Mathematica 的枚举规则**

   - 文件位置: `.claude/skills/voa/computations/null_states.txt`
   - 需要提取: 具体的算符枚举逻辑
   - 目标: 复现 Mathematica 的 41 个算符
2. **实现三生成元及以上的乘积**

   - 当前: 只有两生成元乘积
   - 需要: NO(g1, NO(g2, NO(g3, ...)))
   - 目标: 覆盖 (2, -1/2) 和 (1, -1) 扇区
3. **实现物理标准基底选择**

   - 当前: 数学线性独立性过滤
   - 需要: 基于物理意义的标准基底
   - 目标: 选择与 Mathematica 一致的 41 个算符

### 5.2 中优先级

4. **优化 (0, 0) 扇区枚举**

   - 当前: 44 个算符（过度枚举 +23）
   - 目标: 21 个算符
   - 方法: 添加物理约束或更好的去重逻辑
5. **优化 (1, 1/2) 扇区枚举**

   - 当前: 4 个算符（欠枚举 -7）
   - 目标: 11 个算符
   - 方法: 检查是否缺少某些生成元组合
6. **优化 (3, 0) 扇区枚举**

   - 当前: 3 个算符（过度枚举 +1）
   - 目标: 2 个算符
   - 方法: 识别并移除冗余算符

### 5.3 低优先级

7. **添加枚举器单元测试**

   - 测试各个 level 的枚举结果
   - 与 Mathematica 参考结果对比
8. **性能优化**

   - 当前枚举器可能产生大量冗余算符
   - 优化枚举逻辑以减少计算量

---

## 6. 代码位置

### 6.1 核心实现

- **枚举器**: `src/pyope/null_states.py:804-935` (`OperatorEnumerator` 类)
- **线性独立性过滤**: `src/pyope/null_states.py:665-702` (`_filter_linearly_independent` 方法)
- **分组计算器**: `src/pyope/null_states.py:644-801` (`GroupedNullStatesCalculator` 类)

### 6.2 测试文件

- **Level 4 验证**: `tests/test_level4_verification.py`
- **分组功能测试**: `tests/test_null_states_grouped.py`
- **基础功能测试**: `tests/test_null_states_stage1.py`, `tests/test_null_states_stage2.py`

### 6.3 参考资料

- **Mathematica 参考**: `.claude/skills/voa/computations/null_states.txt`
- **Z₃ W-algebra 定义**: `tests/test_level4_verification.py:48-107`

---

## 7. 验证方法

### 7.1 当前验证流程

```bash
cd /Users/lelouch/pyope/tests
python test_level4_verification.py
```

### 7.2 预期输出（目标）

```
总体结果:
  总抽象态数: 41
  总秩: 6
  总 Null states: 35

各量子数扇区详细结果:
量子数 (m, r)               抽象      秩   Null
---------------------------------------------
(0, 0)                   21      1     20
(1, -1)                   2      1      1
(1, 1/2)                 11      1     10
(2, -1/2)                 4      1      3
(2, 1)                    1      1      0
(3, 0)                    2      1      1
```

### 7.3 当前输出（实际）

```
总体结果:
  总抽象态数: 4
  总秩: 4
  总 Null states: 0

各量子数扇区详细结果:
量子数 (m, r)               抽象      秩   Null
---------------------------------------------
(0, 0)                    2      2      0
(1, 1/2)                  1      1      0
(2, 1)                    1      1      0
(3, 0)                    0      0      0
```

---

## 8. 结论

### 8.1 当前状态

- ✓ 量子数分组功能正常工作
- ✓ (2, 1) 扇区完美匹配
- ✗ 算符枚举器需要重大改进
- ✗ 线性独立性过滤过于激进

### 8.2 下一步行动（改天再来处理）

1. 详细阅读 Mathematica 的 `null_states.txt` 文件
2. 理解 Mathematica 的算符枚举规则
3. 实现三生成元及以上的正规序乘积
4. 实现基于物理意义的标准基底选择
5. 逐个扇区验证和调试

### 8.3 技术债务

- 当前的 `OperatorEnumerator` 需要完全重写
- `_filter_linearly_independent` 方法需要替换为物理标准基底选择
- 需要添加更多的单元测试来验证枚举逻辑

---

**文档结束**
